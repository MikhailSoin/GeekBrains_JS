// Не выполняя кода, ответить, что выведет браузер и почему:

// Пример 1
if (!("a" in window)) {
    var a = 1;
}
alert(a);
// Переменная "a", объявляется при синаксическом анализе. И по итогу перед условием уже существует
// переменная "a" в глобальной области видимости, то есть window.a . Только вот значения у неё нет 'undefined'.
// И получается при таком раскладе мы внутрь условия не попадаем, т.к. !("a" in window) == !true, т.е false
// Как результат на 7 строке мы получаем 'undefined'.

// Пример 2
var b = function a(x) {
    x && a(--x);
};
alert(a);
// Функция a is not defined.
// Результат такой, потому что это именнованне функциональное выражение.
// Получается function a не существует в глобальной области видимости, только внутри
// переменной b. Насколько я понял функция a замкнута на переменной b

// Пример 3
function a(x) {
    return x * 2;
}
var a;
alert(a);
// Здесь выведется текст функции.
// В первую очередь будет объявлена переменная.
// Потом движок найдёт функцию a и перезапишет переменную. На момент вызова на 32 строке, именно функция будет
// записана под именем a, но выведется не результат функции, а сама функия, т.к. отсутствует действие вызова ().

// Пример 4
function b(x, y, a) {
    arguments[2] = 10;
    alert(a);
}
b(1, 2, 3);
// Будет выведена 10
// В объекте-массиве arguments, содержатся все аргументы функции, отсчёт, как и везде начинаеся с 0 индекса
// В данном прмере arguments[0] это x, arguments[1] это y, а arguments[2] это как раз a.
// Внутри функции мы прсваиваем переменной a значение 10. Оно и выводится.

// Пример 5
function a() {
    alert(this);
}
a.call(null);
// В нестрогом режиме выведется глобальный обёъкт window(или global в node.js)
// А в сторогом режиме будет null, потому что мы вызываем функцию по сути без контеста.